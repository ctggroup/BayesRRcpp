---
title: "R Notebook"
output:
  html_document: default
  html_notebook: default
---

This outlines the use of the  BayesRv2 with group variance parameters.

The for a linear model:


$$ \mathbf{y} = \mu +\mathbf{X}\beta + \mathbf{Z}\lambda + ... + \mathbf{e}$$
With $\mathbf{y}$ being the vector of phenotypic traits, matrices $\mathbf{X} $ and $\mathbf{Z}$ being the covariates of interest (marker data and metilation data for example) and their corresponding effects being $\beta,\lambda$ and $\mathbf{e}$ the vector of normal i.i.d. residuals with variance $\sigma_{e}^2$ we can run the BayesR model assuming a normal prior with a group specific variance parmaeter. 

Additionally we could split the effects of a single covariate into many groups without need to change the structure from a single regression problem, this comes as we can express the sum of matrix multiplications as a single matrix multiplication, that is 
$$ \mathbf{X}\beta + \mathbf{Z}\lambda + ... + = \left[\mathbf{X},\mathbf{Z}, .... ,\right]\begin{bmatrix} \alpha \\ \beta \\ ... \end{bmatrix}  $$
 
Here we generate a data set with 2000 effects, 900 of have in total 0.01 of variance and the other 100 have in total 0.49 of variance, together they amount to the total genetic variance. The rest are set to zero, again we are not limited to a single source of information as adding a new group of covariates amounts to just concatenating the design matrices  

We generate the data and run BayesR fortran

```{r,results='hold',eval=FALSE}
require(BayesRRcpp)
require(bindata)
require(readr)

MT = 6000
N = 4000
M1 = 900
M2= 100
M3=2
X <- matrix(rbinom(n=MT*N, 2, .5), ncol=MT)
X1 <- X
b <- c(rnorm(M1,0,sqrt(0.1/(M1))),rnorm(M2,0,sqrt(0.48/(M2))),rnorm(M3,0,sqrt(0.1/(M3))),rep(0,(MT-(M1+M2+M3))))
g <- scale(X) %*% b;
print(c("total genetic variance :",var(g),"\n"))
e <- rnorm(N,0, sqrt(0.5))
y = g + e
X[X == 2] <- "GG"
X[X == 1] <- "AG"
X[X == 0] <- "AA"
ped <- data.frame(fid = 1:N, iid = 1:N, pid = rep(0,N), mid = rep(0,N), sex = rep(1,N), y = y, X)
write.table(ped, paste("simG.ped",sep=''), row.names=F, col.names=F, quote=F)
map <- data.frame(chr = rep(1, MT), rs = paste("rs",1:MT,sep=''),  cm = rep(0,MT), bp = 1:MT)
write.table(map, paste("simG.map",sep=''), row.names=F, col.names=F, quote=F)

# use plink to convert to binary
system("./plink --file simG  --make-bed --out simG")

# run BayesR
start.time <- Sys.time()
#system("../../ctggroup/bayesR/bin/bayesRv2 -bfile simG -burnin 15000 -thin 5 -numit 20000 -out simG")
write.table((as.numeric(Sys.time() - start.time)*60), "time2.txt", row.names=F, col.names=F, quote=F)

save.image("simulationGroups.RData")


```

We run BayesR C++ version

```{r bayesR,results='hold',eval=FALSE}
require(BayesRRcpp)
require(readr)
load("simulationGroups.RData")
# run our version
Y <- y
XX <- scale(X1)
XX<-scale(X)
P=0.5 #prior probability of a marker being excluded from the model
sigma0=0.01# prior  variance of a zero mean gaussian prior over the mean mu NOT IMPLEMENTED
v0E= 0.0001 # degrees of freedom over the inv scaled chi square prior over residuals variance
s02E = 0.001 #scale of the inv scaled chi square prior over residuals variance
v0G = 0.0001 #degrees of freedom of the inv bla bla prior over snp effects
s02G = 0.001 # scale for the samecva 
cva=as.matrix(c(0.0001,0.001,0.01)) #components variance

BayesRSamplerV2("./simG.csv",2, 15000, 10000,1,XX, Y,sigma0,v0E,s02E,v0G,s02G,cva)



```

The output of BayesR C++

```{r bayesRresults,results='hold'}
load("simulationGroups.RData")
#read in the output files
br_p <- read.table("simG.param", header=T)
br_h <- read.table("simG.hyp", header=T)
tmp <- read.csv("simG.csv")
#correlation of true and estimated values
print(c("correlation of squared coefficients between bayesR C++ and true values: ",cor(b^2,colMeans(tmp[,grep("beta",names(tmp))])^2)))
print(c("correlation of squared coefficients between bayesR Fortran and true values: ",cor(b^2,br_p$beta^2)))
print(c("correlation of squared coefficients between bayesR fortran and BayesR C++: ",cor(br_p$beta^2,colMeans(tmp[,grep("beta",names(tmp))])^2)))

print(c("correlation of  coefficients between bayesR C++ and true values: ",cor(b,colMeans(tmp[,grep("beta",names(tmp))]))))
print(c("correlation of  coefficients between bayesR Fortran and true values: ",cor(b,br_p$beta)))
print(c("correlation of  coefficients between bayesR fortran and BayesR C++: ",cor(br_p$beta,colMeans(tmp[,grep("beta",names(tmp))]))))

#estimates of PVE
#ypred <- as.matrix(tmp[,grep("pred",names(tmp))])
#e <- -1 * sweep(ypred, 2, y)
#var_ypred <- apply(ypred, 1, var)
#var_e <- apply(e, 1, var)
#print(c("bayesian R2: ",median(var_ypred / (var_ypred + var_e))))

print(c("BayesR C++ PVE",colMeans(as.matrix(tmp[,grep("sigmaG",names(tmp))]))))
print(c("BayesR Fortran PVE",mean(br_h$Va)))

print(c("BayesR C++ residuals variance",mean(tmp$sigmaE)))
print(c("BayesR Fortran residuals variance",mean(br_h$Ve)))
hist(as.matrix(tmp[,grep("comp",names(tmp))]))
```

Here we run the Group version of BayesR, we have to add a parameter indicating how many groups of variables are there and a vector indicating the membership of each variable (indexes starting at 0, VERY IMPORTANT)

```{r bayesRgroups,eval=FALSE}

load("simulationGroups.RData")
# run our version
Y <- y
XX <- scale(X1)
P=0.5 #prior probability of a marker being excluded from the model
sigma0=0.01# prior  variance of a zero mean gaussian prior over the mean mu NOT IMPLEMENTED
v0E= 0.0001 # degrees of freedom over the inv scaled chi square prior over residuals variance
s02E = 0.001 #scale of the inv scaled chi square prior over residuals variance
v0G = 0.0001 #degrees of freedom of the inv bla bla prior over snp effects
s02G = 0.001 # scale for the samecva 
cva=as.matrix(c(0.00001,0.0001,0.001,0.01)) #components variance
#cva=c(1)

G= 2 #number of groups
GroupAssignment= c(rep(0,M1),rep(1,M2),rep(1,M3),sample(c(0,1),MT-(M1+M2+M3),replace=T))

BayesRSamplerV2Groups("./simGroups.csv",2, 20000, 15000,5,XX, Y,sigma0,v0E,s02E,v0G,s02G,cva,G,GroupAssignment)

```

The results of BayesR groups are

```{r, results='hold'}
load("simulationGroups.RData")
#read in the output files
br_p <- read.table("simG.param", header=T)
br_h <- read.table("simG.hyp", header=T)
tmp <- read.csv("simGroups.csv")
#correlation of true and estimated values
print(c("correlation of squared coefficients between bayesR Groups C++ and true values: ",cor(b^2,colMeans(tmp[,grep("beta",names(tmp))])^2)))
print(c("correlation of squared coefficients between bayesR Fortran and true values: ",cor(b^2,br_p$beta^2)))
print(c("correlation of squared coefficients between bayesR fortran and BayesR Groups C++: ",cor(br_p$beta^2,colMeans(tmp[,grep("beta",names(tmp))])^2)))

print(c("correlation of  coefficients between bayesR Groups C++ and true values: ",cor(b,colMeans(tmp[,grep("beta",names(tmp))]))))
print(c("correlation of  coefficients between bayesR Fortran and true values: ",cor(b,br_p$beta)))
print(c("correlation of  coefficients between bayesR fortran and BayesR Groups C++: ",cor(br_p$beta,colMeans(tmp[,grep("beta",names(tmp))]))))

#estimates of PVE
#ypred <- as.matrix(tmp[,grep("pred",names(tmp))])
#e <- -1 * sweep(ypred, 2, y)
#var_ypred <- apply(ypred, 1, var)
#var_e <- apply(e, 1, var)
#print(c("bayesian R2: ",median(var_ypred / (var_ypred + var_e))))

print(c("BayesR Groups C++ PVE",colMeans(as.matrix(tmp[,grep("sigmaG",names(tmp))]))))
print(c("BayesR Fortran PVE",mean(br_h$Va)))

print(c("BayesR C++ Groups residuals variance",mean(tmp$sigmaE)))
print(c("BayesR Fortran residuals variance",mean(br_h$Ve)))
hist(as.matrix(tmp[,grep("comp",names(tmp))]))
```




Finally, here we use a continuous spike and slab model, here each effect has an individual local variance parameter and a global sparsity parameter given by a beta-bernoulli distribution.


```{r spike,results='hold',eval=F}
load("simulationGroups.RData")
Y <- y
XX <- scale(X1)
vL=0.001 #degrees of freedom local variance parameter
sL=0.001 #scale local variance parameters
A=c(0.000005,1) #spike and slab variances respectively
B=100 #number of blocks to perform sampling
a=0.75 #prior parameter of beta distribution controling sparsity
b=0.75 #prior parameter of beta distribution controling sparsity
#Here we parametrised a and b such that the expected number of zeros =50% with a variance of 0.1
spikeSlab("./simSpike.csv",1, 50000,30000 ,10,XX, Y,A,0.001,0.001,vL,sL,B,a,b)

HorseshoePlusv2("./simSpike.csv",1, 15000,10000 ,5,scale(X), y,0.00001, 0.0001, 0.00001,1, 1, 1,0.01)
```

```{r spikeresults,results='hold'}
#read in the output files
br_p <- read.table("simG.param", header=T)
br_h <- read.table("simG.hyp", header=T)


tmp <- read.csv("simSpike.csv")
#correlation of true and estimated values
print(c("correlation of squared coefficients between spikeslab C++ and true values: ",cor(b^2,colMeans(tmp[,grep("beta",names(tmp))])^2)))
print(c("correlation of squared coefficients between bayesR Fortran and true values: ",cor(b^2,br_p$beta^2)))
print(c("correlation of squared coefficients between bayesR fortran and spikeslab C++: ",cor(br_p$beta^2,colMeans(tmp[,grep("beta",names(tmp))])^2)))

print(c("correlation of  coefficients between spikeslab C++ and true values: ",cor(b,colMeans(tmp[,grep("beta",names(tmp))]))))
print(c("correlation of  coefficients between bayesR Fortran and true values: ",cor(b,br_p$beta)))
print(c("correlation of  coefficients between bayesR fortran and spikeslab C++: ",cor(br_p$beta,colMeans(tmp[,grep("beta",names(tmp))]))))

#estimates of PVE
#ypred <- as.matrix(tmp[,grep("pred",names(tmp))])
#e <- -1 * sweep(ypred, 2, y)
#var_ypred <- apply(ypred, 1, var)
#var_e <- apply(e, 1, var)
#print(c("bayesian R2: ",median(var_ypred / (var_ypred + var_e))))


print(c("spikeslab C++ residuals variance",mean(tmp$sigmaE)))
print(c("BayesR Fortran residuals variance",mean(br_h$Ve)))
```

